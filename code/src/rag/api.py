from contextlib import asynccontextmanager
from fastapi import Depends, FastAPI, Request, HTTPException, BackgroundTasks
from pydantic import BaseModel
from rag.rag_core import APIRAGSystem
from rag.app_settings import RetrieverType
from rag.app_settings import AppSettings
from utils.vprint import vprint
import requests
import traceback

# *** App FastAPI ***
__VERSION__ = "1.0.0"
app = FastAPI(
    title="API Medial RAG System",
    description="API to query a Medical RAG system with different retrievers.",
    version=__VERSION__
)

# *** Data Model ***
class QueryRequest(BaseModel):
    is_multi_opt: bool = False
    query: str
    opts: dict = {}

class IndexRequest(BaseModel):
    size: int

# *** Global Settings ***

def check_qdrant_connection(host: str = "localhost", port: int = 6333, timeout: float = 2.0) -> bool:
    url = f"http://{host}:{port}"
    try:
        print(f"Checking Qdrant connection at {url} with timeout {timeout} seconds...")
        resp = requests.get(url, timeout=timeout)
        print(f"Response from Qdrant: {resp.status_code} - {resp.text}")
        return resp.status_code == 200 and "qdrant" in resp.json().get('title')
    except (requests.RequestException, ValueError) as e:
        print(f"Error checking Qdrant connection: {e}")
        return False


def check_ollama_connection(host: str = "localhost", port: int = 11434, timeout: float = 2.0) -> bool:
    url = f"http://{host}:{port}/v1/models"
    try:
        print(f"Checking Ollama connection at {url} with timeout {timeout} seconds...")
        resp = requests.get(url, timeout=timeout)
        return resp.status_code == 200 and isinstance(resp.json().get('data'), list)
    except (requests.RequestException, ValueError) as e:
        print(f"Error checking Ollama connection: {e}")
        return False
    
@asynccontextmanager
async def lifespan(app: FastAPI):
    app_settings = AppSettings()
    if not check_qdrant_connection(app_settings.db_host, app_settings.db_port):
        raise RuntimeError(f"Qdrant connection failed at {app_settings.db_host}:{app_settings.db_port}")
    if not check_ollama_connection(app_settings.ollama_host, app_settings.ollama_port):
        raise RuntimeError(f"Ollama connection failed at {app_settings.ollama_host}:{app_settings.ollama_port}")
    print("--> [API] Initializing RAG systems...")
    api_rag_system = APIRAGSystem(app_settings)
    await api_rag_system.initialize_rag_systems()
    app.state.controller_rags_system = api_rag_system
    yield

def get_controller(request: Request) -> APIRAGSystem:
    return request.app.state.controller_rags_system

app = FastAPI(lifespan=lifespan)

# *** Endpoints de la API ***

@app.get("/health", tags=["Status"])
def read_root():
    return {"status": "API is running", "version": __VERSION__}


@app.post("/{retriever_type}/index", tags=["RAG"])
async def index_documents(retriever_type: RetrieverType, request: IndexRequest, background_tasks: BackgroundTasks, controller: APIRAGSystem = Depends(get_controller)):
    """
    Indexes documents for the specified retriever type.
    """
    print(f"--> [API] Indexing documentes with retriever type: {retriever_type}")
    try:
        rag_system = controller.get_rag_system(retriever_type)
        #rag_system.index_documents(subset_size=request.size)
        background_tasks.add_task(rag_system.index_documents, subset_size=request.size)
        result = {"message": f"Documents being indexed in background: {retriever_type}"}
        vprint(AppSettings.VERBOSE, f"[API] {result['message']}")
        return result
    except Exception as e:
        print(f"--> [API] Error: {e}: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))
    
@app.post("/{retriever_type}/query", tags=["RAG"])
async def process_query(retriever_type: RetrieverType, request: QueryRequest, controller: APIRAGSystem = Depends(get_controller)):
    """
    Receives a query and returns the response generated by the RAG system.
    """
    vprint(AppSettings.VERBOSE, f"[API] Request received. RAG: {retriever_type}")

    if not request.query.strip():
            raise HTTPException(status_code=400, detail="Query cannot be empty.")
    
    try:
        rag_system = controller.get_rag_system(retriever_type)
        result = rag_system.query(user_query=request.query, is_multi_opt=request.is_multi_opt, options=request.opts)
        return result
    except Exception as e:
        print(f"--> [API] Error: {e}: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))
    